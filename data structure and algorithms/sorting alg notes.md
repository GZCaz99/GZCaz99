# Intro 
这篇是关于排序算法的相关笔记

### 常见排序算法
>![1673927378749](https://user-images.githubusercontent.com/89850899/212805854-df4abbe2-e57e-41aa-a04c-9488250fc6f0.png)

要记住他们的平均时间复杂度

#### 选择排序
从上图可以了解, 选择排序是最低效的排序方法. 该方法的基本步骤分为:
- 扫描列表中并记录最小值的index
- 扫描剩余input, 如果有更小的值, 就将它与上一个值的位置对调

该排序算法在python的实现如下:
>![1673943632669](https://user-images.githubusercontent.com/89850899/212845317-bda78c8f-9ff5-472b-93fe-81c6b9efa5b2.png)

值得注意的是该算法中使用了 variable 来储存 index. 这里的i是对列表的每个位置进行循环, 即从第一位到第i-1位, 上图中code也有for i in range 而不是 for i in list  (i/j 在这里都是).
上图的算法是针对升序的需求而写出的, 即当更小的数被扫描到时则将其前移, 针对降序则可以将小于号换成大于号. 该算法的核心是通过将输入数列不断划分成更小的几个子集来进行比较, 在运行中永远是当前i 位置的数字和所有剩余的值作比较, 所以时间上效率不高.

#### 冒泡排序
冒泡排序是与选择排序相似的排序算法, 该方法的基本步骤分为:
- 对于长度为n的数列, 从第一个数开始, 两个两个比较, 如果后面的数值大于前面的,则把这两个数字的位置调换.

该算法在python的实现如下:

>![1674028616130](https://user-images.githubusercontent.com/89850899/213115130-2009c463-df0e-42ed-b116-a2e85af74c44.png)

该算法的核心难点也在于循环次数的处理, 因为该算法中永远只是与 *目前选定* 的和 *与目前选定的值相邻* 的两个input比较, 并不像选择排序那样每次都是 *选定的* 与 *所有其他的* 值进行比较, 所以冒泡选择的效率会稍高, 运行也更稳定


#### 插入排序
对于比较有序的数列最好用,也是稳定的排序算法之一.该算法有点像是之前两个算法的集合, 即有所有剩余input的比较,而同时该比较模式也是依次进行的,具体原理如下:
> 对一个随机生成的数列: [9,6,1,3,5]
> 算法首先从第二个数 6 开始往前扫描, 发现6比9小, 所以将他们的位置调换.下一次循环则从第三位数字 1 开始, 这次循环中 1 将于前面的两个数字依次比较, 发现 1 比他们都小,所以将他移到最前方.第三次循环从 3 开始, 发现 3 比 9 和 6 都小, 但比 1 大, 所以在发现被循环的input 大于 前一位 input 时停下, 并将 3 插入到 1 后面. 而最后一个input 5 也是同样的步骤,最后插入到6的前面, 3 的后面.
> 总结: 该算法本质上是一个 **不断往已排序的子列表里插入原数列中后续的input** 的循环

>该算法在python中的实现如下:
>![1674140812394](https://user-images.githubusercontent.com/89850899/213477968-a867abbe-657b-4f92-aa60-2034f87bfa07.png)

总结:
- 冒泡排序 -- 基本不用 太慢
- 选择排序 -- 基本不用 不稳定
- 插入排序 -- 样本小且基本有序时效率会较高

#### 希尔排序
希尔排序是插入排序的优化版, 它先将输入列表分成若干个[i,i+d,i+2d, ....] 的子表.其中 d 是一个'距离值', 即相距 d 个 index 的值 并对这些子表进行插入排序, 再缩小d的值, 再对生成的子表进行插入排序, 如此循环直至d最终 = 1. 比如说对于一个 len 为 8 的数列, 第一次时设 d = 4, 则会生成 4 个 子表, 每个子表长度为 2. 第二次设 d = d/2 = 2;第三次设 d = d/2 = 1, 此时d = 1,结束循环. 再该算法中 缩减值 d 是可以自由决定的, 但一般设为前一次循环的一半. 算法在python的实现如下:

>![1674201654276](https://user-images.githubusercontent.com/89850899/213645810-d10a9406-5115-4d93-af23-53a274777df2.png)


#### 归并排序
归并排序是希尔排序的进阶, 在希尔排序中, 可能会遇到某个子表其实已经排列好的情况却仍会尽力一边循环,其次, 不断地将输入数列分成相距为 d 的子数列也不是很有效率. 归并排序的出现改进了这个缺陷, 并且使得排序更加稳定. 该算法有两个部分组成, 一部分是将原数列不断对半分成更小的数列,直到某个数列中只剩下最后一个数列, 另一部分则是排序, 在各个子数组设定一个中点并以此划分出left/right 两个子数组进行比较, 当左边大于右边时, 右边的数就插入到原数列, 之后右数列指针往后移一位,而反之亦然. 对于剩下的子数列(在给定输入数列长度为奇数时会发生)没有比较对象时候则依次将该数列中剩余的input加入原数列,最后return 已排序数列. 该算法在python中的实现如下:

>![1674654261319](https://user-images.githubusercontent.com/89850899/214579240-339d1fc4-2fc5-450f-956d-958d76d90c33.png)

#### 快速排序
快速排序会在输入数列中设置一个 *pivot*, 之后再对比整个数列,并将比它大的input移到右边, 而比它小的移到左边, 形成一个 *smaller/pivot/bigger* 结构的数列, 之后再对pivot两边的子数列递归的重复上述步骤, 直到最后的子数列只剩下一个值, 再层层返回得到最终的已排序数列. 在该算法中pivot的选取是可自定义的,在下面的实现中则将每个数列中的第一个值设为pivot:
>![1675211959145](https://user-images.githubusercontent.com/89850899/215916417-279c664d-03be-483b-b756-be19df1d4664.png)
>代码的实现来自https://www.youtube.com/watch?v=duln2xAZhBA

#### 记数排序








